<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Interactive Coordinate Triangle</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			display: flex;
			flex-direction: column;
			align-items: center;
			padding: 20px;
			background-color: #f0f0f0;
		}

		#canvas {
			border: 2px solid #333;
			background-color: white;
			cursor: crosshair;
		}

		.main-content {
			display: flex;
			align-items: flex-start;
			gap: 30px;
			margin-top: 20px;
		}

		.sidebar {
			display: flex;
			flex-direction: column;
			width: 300px;
			gap: 20px;
		}

		.instructions {
			text-align: left;
			background-color: white;
			padding: 20px;
			border-radius: 8px;
			border: 1px solid #ddd;
			box-shadow: 0 2px 4px rgba(0,0,0,0.1);
		}

		.instructions h3 {
			margin-top: 0;
			color: #333;
			font-size: 18px;
		}

		.instructions p {
			margin: 10px 0;
			line-height: 1.5;
			color: #555;
		}

		.controls {
			background-color: white;
			padding: 20px;
			border-radius: 8px;
			border: 1px solid #ddd;
			box-shadow: 0 2px 4px rgba(0,0,0,0.1);
		}

		.controls h3 {
			margin-top: 0;
			color: #333;
			font-size: 18px;
		}

		button {
			padding: 12px 20px;
			border: none;
			background-color: #4CAF50;
			color: white;
			border-radius: 6px;
			cursor: pointer;
			font-size: 14px;
			font-weight: 500;
			width: 100%;
		}

		button:hover {
			background-color: #45a049;
		}

		button:disabled {
			background-color: #cccccc;
			cursor: not-allowed;
		}

		@media (max-width: 1024px) {
			.main-content {
				flex-direction: column;
				align-items: center;
			}

			.sidebar {
				width: 100%;
				max-width: 640px;
			}
		}
	</style>
</head>
<body>
	<h1>Interactive Coordinate Triangle</h1>

	<div class="main-content">
		<svg id="canvas" width="640" height="640"></svg>

		<div class="sidebar">
			<div class="instructions">
				<h3>Instructions</h3>
				<p>Click on any grid intersection (integer coordinates) to place up to 3 points.</p>
				<p>Once placed, you can drag the points to move them to different integer coordinates.</p>
				<p>The triangle will update automatically and show the angles at each vertex.</p>
			</div>

			<div class="controls">
				<h3>Controls</h3>
				<button onclick="clearPoints()">Clear All Points</button>
			</div>
		</div>
	</div>

	<script>
		const canvas = document.getElementById('canvas');
		const canvasSize = 640;
		const gridSize = 32; // Larger grid size for better visibility
		const centerX = canvasSize / 2;
		const centerY = canvasSize / 2;

		let points = [];
		let draggedPoint = null;
		let dragOffset = { x: 0, y: 0 };

		// Convert screen coordinates to grid coordinates
		function screenToGrid(screenX, screenY) {
			const rect = canvas.getBoundingClientRect();
			const x = screenX - rect.left;
			const y = screenY - rect.top;

			const gridX = Math.round((x - centerX) / gridSize);
			const gridY = Math.round((centerY - y) / gridSize);

			// Clamp to grid bounds (-10 to 10)
			return {
				x: Math.max(-10, Math.min(10, gridX)),
				y: Math.max(-10, Math.min(10, gridY))
			};
		}

		// Convert grid coordinates to screen coordinates
		function gridToScreen(gridX, gridY) {
			return {
				x: centerX + gridX * gridSize,
				y: centerY - gridY * gridSize
			};
		}

		// Draw the coordinate grid
		function drawGrid() {
			canvas.innerHTML = '';

			// Create SVG elements
			const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
			canvas.appendChild(defs);

			// Grid lines
			const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
			gridGroup.setAttribute('stroke', '#ddd');
			gridGroup.setAttribute('stroke-width', '1');

			// Vertical lines (only from -10 to 10)
			for (let i = -10; i <= 10; i++) {
				const x = centerX + i * gridSize;
				const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
				line.setAttribute('x1', x);
				line.setAttribute('y1', centerY - 10 * gridSize);
				line.setAttribute('x2', x);
				line.setAttribute('y2', centerY + 10 * gridSize);
				gridGroup.appendChild(line);
			}

			// Horizontal lines (only from -10 to 10)
			for (let i = -10; i <= 10; i++) {
				const y = centerY - i * gridSize;
				const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
				line.setAttribute('x1', centerX - 10 * gridSize);
				line.setAttribute('y1', y);
				line.setAttribute('x2', centerX + 10 * gridSize);
				line.setAttribute('y2', y);
				gridGroup.appendChild(line);
			}

			canvas.appendChild(gridGroup);

			// Axes
			const axesGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
			axesGroup.setAttribute('stroke', '#333');
			axesGroup.setAttribute('stroke-width', '2');

			// X-axis
			const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
			xAxis.setAttribute('x1', centerX - 10 * gridSize);
			xAxis.setAttribute('y1', centerY);
			xAxis.setAttribute('x2', centerX + 10 * gridSize);
			xAxis.setAttribute('y2', centerY);
			axesGroup.appendChild(xAxis);

			// Y-axis
			const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
			yAxis.setAttribute('x1', centerX);
			yAxis.setAttribute('y1', centerY - 10 * gridSize);
			yAxis.setAttribute('x2', centerX);
			yAxis.setAttribute('y2', centerY + 10 * gridSize);
			axesGroup.appendChild(yAxis);

			canvas.appendChild(axesGroup);

			// Grid intersection points
			const pointsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
			pointsGroup.setAttribute('fill', '#ccc');

			for (let x = -10; x <= 10; x++) {
				for (let y = -10; y <= 10; y++) {
					const screenPos = gridToScreen(x, y);
					const point = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
					point.setAttribute('cx', screenPos.x);
					point.setAttribute('cy', screenPos.y);
					point.setAttribute('r', '2');
					pointsGroup.appendChild(point);
				}
			}

			canvas.appendChild(pointsGroup);

			// Labels
			const labelsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
			labelsGroup.setAttribute('fill', '#666');
			labelsGroup.setAttribute('font-family', 'Arial, sans-serif');
			labelsGroup.setAttribute('font-size', '14');
			labelsGroup.setAttribute('text-anchor', 'middle');

			// X-axis labels (every 2 units for clarity)
			for (let i = -10; i <= 10; i += 2) {
				if (i === 0) continue;
				const x = centerX + i * gridSize;
				const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
				label.setAttribute('x', x);
				label.setAttribute('y', centerY + 25);
				label.textContent = i.toString();
				labelsGroup.appendChild(label);
			}

			// Y-axis labels (every 2 units for clarity)
			for (let i = -10; i <= 10; i += 2) {
				if (i === 0) continue;
				const y = centerY - i * gridSize;
				const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
				label.setAttribute('x', centerX - 25);
				label.setAttribute('y', y + 5);
				label.textContent = i.toString();
				labelsGroup.appendChild(label);
			}

			canvas.appendChild(labelsGroup);
		}

		// Draw triangle and points
		function drawTriangleAndPoints() {
			// Remove existing triangle and points
			const existingTriangle = canvas.querySelector('#triangle');
			const existingPoints = canvas.querySelector('#userPoints');
			if (existingTriangle) existingTriangle.remove();
			if (existingPoints) existingPoints.remove();

			// Calculate angles if we have 3 points
			let angles = [null, null, null];
			let isCollinear = false;

			if (points.length === 3) {
				// Draw triangle
				const triangle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
				triangle.setAttribute('id', 'triangle');

				const screenPoints = points.map(p => gridToScreen(p.x, p.y));
				const pointsStr = screenPoints.map(p => `${p.x},${p.y}`).join(' ');
				triangle.setAttribute('points', pointsStr);
				triangle.setAttribute('fill', 'rgba(74, 144, 226, 0.3)');
				triangle.setAttribute('stroke', '#4a90e2');
				triangle.setAttribute('stroke-width', '2');

				canvas.appendChild(triangle);

				// Calculate angles
				const [p1, p2, p3] = points;
				const area = Math.abs(
					(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2
				);

				if (area > 0.001) { // Not collinear
					angles[0] = calculateAngle(p2, p1, p3); // Angle at P1
					angles[1] = calculateAngle(p1, p2, p3); // Angle at P2
					angles[2] = calculateAngle(p1, p3, p2); // Angle at P3
				} else {
					isCollinear = true;
				}
			}

			// Draw user points
			const pointsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
			pointsGroup.setAttribute('id', 'userPoints');

			points.forEach((point, index) => {
				const screenPos = gridToScreen(point.x, point.y);

				// Point circle
				const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
				circle.setAttribute('cx', screenPos.x);
				circle.setAttribute('cy', screenPos.y);
				circle.setAttribute('r', '10');
				circle.setAttribute('fill', '#e74c3c');
				circle.setAttribute('stroke', 'white');
				circle.setAttribute('stroke-width', '2');
				circle.setAttribute('cursor', 'move');
				circle.setAttribute('data-point-index', index);

				// Point coordinate label
				const coordLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
				coordLabel.setAttribute('x', screenPos.x);
				coordLabel.setAttribute('y', screenPos.y - 18);
				coordLabel.setAttribute('fill', '#333');
				coordLabel.setAttribute('font-family', 'Arial, sans-serif');
				coordLabel.setAttribute('font-size', '16');
				coordLabel.setAttribute('font-weight', 'bold');
				coordLabel.setAttribute('text-anchor', 'middle');
				coordLabel.textContent = `P${index + 1}(${point.x},${point.y})`;
				coordLabel.setAttribute('pointer-events', 'none');

				// Angle label (if we have 3 points and they form a valid triangle)
				if (points.length === 3 && !isCollinear && angles[index] !== null) {
					const angleLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');

					// Position angle label to avoid overlap with coordinate label
					let offsetX = 0;
					let offsetY = 0;

					// Determine position based on point index to spread them out
					switch (index) {
						case 0: // P1 - place to the right
							offsetX = 30;
							offsetY = 5;
							break;
						case 1: // P2 - place to the left
							offsetX = -30;
							offsetY = 5;
							break;
						case 2: // P3 - place below
							offsetX = 0;
							offsetY = 30;
							break;
					}

					angleLabel.setAttribute('x', screenPos.x + offsetX);
					angleLabel.setAttribute('y', screenPos.y + offsetY);
					angleLabel.setAttribute('fill', '#2c3e50');
					angleLabel.setAttribute('font-family', 'Arial, sans-serif');
					angleLabel.setAttribute('font-size', '15');
					angleLabel.setAttribute('font-weight', 'bold');
					angleLabel.setAttribute('text-anchor', 'middle');
					angleLabel.textContent = `∠${angles[index].toFixed(1)}°`;
					angleLabel.setAttribute('pointer-events', 'none');

					// Add a subtle background for better readability
					const angleBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');

					angleBg.setAttribute('x', screenPos.x + offsetX - 25);
					angleBg.setAttribute('y', screenPos.y + offsetY - 12);
					angleBg.setAttribute('width', '50');
					angleBg.setAttribute('height', '20');
					angleBg.setAttribute('fill', 'rgba(255, 255, 255, 0.9)');
					angleBg.setAttribute('stroke', 'rgba(44, 62, 80, 0.3)');
					angleBg.setAttribute('stroke-width', '1');
					angleBg.setAttribute('rx', '4');
					angleBg.setAttribute('pointer-events', 'none');

					pointsGroup.appendChild(angleBg);
					pointsGroup.appendChild(angleLabel);
				} else if (points.length === 3 && isCollinear) {
					// Show collinear message for the middle point
					if (index === 1) {
						const collinearLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
						collinearLabel.setAttribute('x', screenPos.x);
						collinearLabel.setAttribute('y', screenPos.y + 30);
						collinearLabel.setAttribute('fill', '#e67e22');
						collinearLabel.setAttribute('font-family', 'Arial, sans-serif');
						collinearLabel.setAttribute('font-size', '12');
						collinearLabel.setAttribute('font-weight', 'bold');
						collinearLabel.setAttribute('text-anchor', 'middle');
						collinearLabel.textContent = 'Collinear';
						collinearLabel.setAttribute('pointer-events', 'none');

						pointsGroup.appendChild(collinearLabel);
					}
				}

				pointsGroup.appendChild(circle);
				pointsGroup.appendChild(coordLabel);
			});

			canvas.appendChild(pointsGroup);
		}

		// Calculate angle between two vectors using dot product
		function calculateAngle(p1, p2, p3) {
			// Calculate vectors from p2 to p1 and p2 to p3
			const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
			const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };

			// Calculate dot product
			const dotProduct = v1.x * v2.x + v1.y * v2.y;

			// Calculate magnitudes
			const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
			const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);

			// Handle degenerate cases
			if (mag1 === 0 || mag2 === 0) return 0;

			// Calculate angle in radians, then convert to degrees
			const cosAngle = Math.max(-1, Math.min(1, dotProduct / (mag1 * mag2))); // Clamp to [-1, 1]
			const angleRadians = Math.acos(cosAngle);
			const angleDegrees = angleRadians * (180 / Math.PI);

			return angleDegrees;
		}

		// Handle canvas click
		function handleCanvasClick(event) {
			if (draggedPoint !== null) return; // Don't add points while dragging

			const targetElement = event.target;

			// Check if clicked on a point
			if (targetElement.tagName === 'circle' && targetElement.hasAttribute('data-point-index')) {
				return; // Let drag handling take care of this
			}

			// Add new point if we have less than 3
			if (points.length < 3) {
				const gridPos = screenToGrid(event.clientX, event.clientY);

				// Check if point already exists at this position
				const exists = points.some(p => p.x === gridPos.x && p.y === gridPos.y);
				if (!exists) {
					points.push(gridPos);
					drawTriangleAndPoints();
				}
			}
		}

		// Handle mouse down for dragging
		function handleMouseDown(event) {
			const targetElement = event.target;

			if (targetElement.tagName === 'circle' && targetElement.hasAttribute('data-point-index')) {
				const pointIndex = parseInt(targetElement.getAttribute('data-point-index'));
				draggedPoint = pointIndex;

				const screenPos = gridToScreen(points[pointIndex].x, points[pointIndex].y);
				const rect = canvas.getBoundingClientRect();
				dragOffset.x = (event.clientX - rect.left) - screenPos.x;
				dragOffset.y = (event.clientY - rect.top) - screenPos.y;

				canvas.style.cursor = 'grabbing';
				event.preventDefault();
			}
		}

		// Handle mouse move for dragging
		function handleMouseMove(event) {
			if (draggedPoint !== null) {
				const rect = canvas.getBoundingClientRect();
				const mouseX = event.clientX - rect.left - dragOffset.x;
				const mouseY = event.clientY - rect.top - dragOffset.y;

				const gridPos = screenToGrid(event.clientX - dragOffset.x, event.clientY - dragOffset.y);

				// Check if position is different and not occupied by another point
				const exists = points.some((p, index) =>
					index !== draggedPoint && p.x === gridPos.x && p.y === gridPos.y
				);

				if (!exists && (points[draggedPoint].x !== gridPos.x || points[draggedPoint].y !== gridPos.y)) {
					points[draggedPoint] = gridPos;
					drawTriangleAndPoints();
				}
			}
		}

		// Handle mouse up
		function handleMouseUp(event) {
			if (draggedPoint !== null) {
				draggedPoint = null;
				canvas.style.cursor = 'crosshair';
			}
		}

		// Clear all points
		function clearPoints() {
			points = [];
			drawTriangleAndPoints();
		}

		// Event listeners
		canvas.addEventListener('click', handleCanvasClick);
		canvas.addEventListener('mousedown', handleMouseDown);
		canvas.addEventListener('mousemove', handleMouseMove);
		canvas.addEventListener('mouseup', handleMouseUp);
		canvas.addEventListener('mouseleave', handleMouseUp);

		// Prevent context menu on right click
		canvas.addEventListener('contextmenu', event => event.preventDefault());

		// Initialize
		drawGrid();
	</script>
</body>
</html>